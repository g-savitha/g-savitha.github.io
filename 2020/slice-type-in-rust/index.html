<!doctype html><html lang=en><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://www.gsavitha.in/css/base.css media=all><link rel=stylesheet href=https://www.gsavitha.in/css/syntax.css media=all><link href="https://fonts.googleapis.com/css2?family=Oxygen:wght@300;400;700&display=swap" rel=stylesheet><script async src=https://kit.fontawesome.com/66c0687ece.js crossorigin=anonymous></script><meta name=description content="slice is a data-type in Rust. Slice references a contiguous sequence from a given collection. one cool thing about slice is, it can accept both String and Slice types(unlike String, which accepts only itself)..."><meta name=title content="Slice Type in Rust | Savitha Gollamudi"><meta name=keywords content="tech,programming,javascript,react,rust,nodejs,node,mongodb,postgresql"><meta name=robots content="index, follow"><meta charset=utf-8><meta name=language content="English"><meta name=revisit-after content="2 days"><meta name=author content="Abdus <mail@abdus.xyz>"><meta property="og:type" content="website"><meta property="og:url" content="https://www.gsavitha.in/2020/slice-type-in-rust/"><meta property="og:title" content="Slice Type in Rust | Savitha Gollamudi"><meta property="og:description" content="slice is a data-type in Rust. Slice references a contiguous sequence from a given collection. one cool thing about slice is, it can accept both String and Slice types(unlike String, which accepts only itself)..."><meta property="og:image" content="https://www.gsavitha.in/images/default-meta-img.png"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://www.gsavitha.in/2020/slice-type-in-rust/"><meta property="twitter:title" content="Slice Type in Rust | Savitha Gollamudi"><meta property="twitter:description" content="slice is a data-type in Rust. Slice references a contiguous sequence from a given collection. one cool thing about slice is, it can accept both String and Slice types(unlike String, which accepts only itself)..."><meta property="twitter:image" content="https://www.gsavitha.in/images/default-meta-img.png"><title>Slice Type in Rust | Savitha Gollamudi</title><meta name=google-site-verification content="SaBE4itR48HOEifszgie57M1Y1O9Ayk_rV5cBwah9LY"><body><small class=top-nav><a href=/>~/</a>
<a href=/me/>~/about</a>
<a href=/categories/>~/categories</a>
<a href=/notes/>~/notes</a>
<a href=/work/>~/work</a></small>
<a href=https://www.gsavitha.in/ style=text-align:center;display:block;margin-top:3rem><div class=logo><span>#"</span><span>Savitha Gollamudi</span><span>"</span></div></a><div id=content><div style="text-align:center;margin:3rem 0"><h2>Slice Type in Rust</h2><small>30 June, 2020&nbsp;&nbsp;&#183;&nbsp;&nbsp;</small>
<small></small></div><div class=section-content style=color:#252525><p>In Rust, there is a concept of borrowing and taking ownership. This is a concept
not many languages implement.</p><h2 id=ownership-and-borrowing>Ownership and Borrowing</h2><p>In a Rust program, any given value is owned by a variable. For instance, if we
declare <code>let a = 30;</code>, value <code>30</code> would be owned by variable <code>a</code>.</p><p>Following is a program to illustrate it:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// won&#39;t compile
</span><span class=c1></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>some_string</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello world&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=hl><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Length {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>str_length</span><span class=p>(</span><span class=n>some_string</span><span class=p>));</span><span class=w>
</span></span><span class=hl><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;string is &#39;{}&#39;&#34;</span><span class=p>,</span><span class=w> </span><span class=n>some_string</span><span class=p>);</span><span class=w>
</span></span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>str_length</span><span class=p>(</span><span class=n>s</span>: <span class=nb>String</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>s</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h3 id=taking-ownership>Taking Ownership</h3><p>Look at the highlighted codeblock. I am passing the variable <code>some_string</code> to
function <code>str_length()</code> which accepts parameter as value. When the function gets
called, the value of <code>some_string</code> <strong>moves</strong> to function <code>str_length</code>, making the
variable unusable after the function
call(here: <code>println!("string is '{}'", some_string);</code>).
This is called <strong>taking ownership</strong>.</p><h3 id=borrowing>Borrowing</h3><p>On the other hand: if I pass argument <code>some_string</code> to <code>str_length</code> by reference,
the ownership would be retained by <code>some_string</code>. A modified version of
<code>str_length</code> signature would look like:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>str_length</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=nb>String</span><span class=p>)</span><span class=w>
</span></code></pre></div><p>This is known as <strong>Borrowing</strong>. It is not quite as simple as it looks like.
There are certains rules which needs to be followed while borrowing a value. For
instance: a variable can be mutated only once at a given scope.</p><h2 id=the-slice-type>The Slice Type</h2><p>A <code>slice</code> is reference to a <strong>contiguous sequence</strong> of elements in a collection.
It does not take ownership(since it just <em>references</em> a sequence).</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// slice of a string
</span><span class=c1></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello, Rust&#34;</span><span class=p>);</span><span class=w>
</span><span class=hl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>sliced_str</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>s1</span><span class=p>[</span><span class=mi>0</span><span class=p>..</span><span class=mi>5</span><span class=p>];</span><span class=w>  </span><span class=c1>// hello
</span></span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>A good thing about slice is that it accepts type <code>String</code> as well as itself
(i.e. <code>str</code> type), unlike <code>String</code>(which does not accept <code>str</code>).</p><blockquote><p>In Rust, <code>..</code> is called as range syntax.</p></blockquote><p>An example would demonstrate it better:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>str1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello, Rust&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>print_str</span><span class=p>(</span><span class=o>&amp;</span><span class=n>str1</span><span class=p>[</span><span class=mi>2</span><span class=p>..</span><span class=mi>4</span><span class=p>]);</span><span class=w> </span><span class=c1>// ll
</span><span class=c1></span><span class=w>    </span><span class=n>print_str</span><span class=p>(</span><span class=o>&amp;</span><span class=n>str1</span><span class=p>);</span><span class=w>       </span><span class=c1>// hello, Rust
</span><span class=c1></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>print_str</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h3 id=slice-varients>Slice Varients</h3><p>Slice comes with quite a few varients, which fits different use cases. Here I am
listing a few:</p><p><strong>Referencing from the start of a Collection:</strong> when referencing from the very
first element in a collection(i.e. 0), one could ommit it. Example: <code>&s[..4]</code>.</p><p>Likewise, when <strong>referencing upto the last element of a collection</strong>, can be
omitted. <code>&s[3..]</code>.</p><p>Similarly, when <strong>referencing the whole collection(i.e. from start to end)</strong>,
one can ommit ranges in range syntax. Example: <code>&s[..]</code></p><h3 id=real-world-example>Real-World Example</h3><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;Hello, world&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>word</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>get_first_word</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>  </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;First word is &#39;{}&#39;&#34;</span><span class=p>,</span><span class=w> </span><span class=n>word</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>get_first_word</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>str</span> <span class=p>{</span><span class=w>
</span><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>str_bytes</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>as_bytes</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>item</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>str_bytes</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>enumerate</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>b&#39; &#39;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=hl><span class=w>      </span><span class=k>return</span><span class=w> </span><span class=o>&amp;</span><span class=n>s</span><span class=p>[</span><span class=mi>0</span><span class=p>..</span><span class=n>i</span><span class=p>];</span><span class=w>
</span></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>  </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=o>&amp;</span><span class=n>s</span><span class=p>[..];</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div></div><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.gsavitha.in\/"},"articleSection":"posts","name":"Slice Type in Rust","headline":"Slice Type in Rust","description":"In Rust, there is a concept of borrowing and taking ownership. This is a concept not many languages implement.\nOwnership and Borrowing In a Rust program, any given value is owned by a variable. For instance, if we declare let a = 30;, value 30 would be owned by variable a.\nFollowing is a program to illustrate it:\n\/\/ won\u0026#39;t compile fn main(){letsome_string=String::from(\u0026#34;hello world\u0026#34;);println!(\u0026#34;Length {}\u0026#34;,str_length(some_string));println!(\u0026#34;string is \u0026#39;{}\u0026#39;\u0026#34;,some_string);}fn str_length(s: String)-\u0026gt; usize {s.","inLanguage":"en-US","author":"Savitha","creator":"Savitha","publisher":"Savitha","accountablePerson":"Savitha","copyrightHolder":"Savitha","copyrightYear":"30300","datePublished":"2020-06-30 12:26:32 \u002b0530 \u002b0530","dateModified":"2020-06-30 12:26:32 \u002b0530 \u002b0530","url":"https:\/\/www.gsavitha.in\/2020\/slice-type-in-rust\/","wordCount":"366","keywords":["Blog"]}</script></div><footer style="padding:6rem 1rem 2rem;text-align:center;color:gray"><small>built with <a href=https://gohugo.io>hugo</a> and
<span style=color:red>❤️</span></small></footer><script>(()=>{if(document.queryCommandSupported("copy")){const codeBlocks=[...document.querySelectorAll(".highlight")];codeBlocks.forEach((block)=>{block.querySelector("pre.chroma").style.paddingTop="3rem";block.style.position="relative";const handler=document.createElement("button");handler.textContent="COPY";handler.style.position="absolute";handler.style.top="10px";handler.style.right="10px";handler.style.padding="0.25rem 0.5rem";handler.style.background="#ffffff";handler.style.borderRadius="4px";handler.style.border="1px solid #C9D5DE";handler.style.color="#2d3748";handler.addEventListener("click",()=>{const textarea=document.createElement("textarea");textarea.value=block.querySelector(".chroma > code").textContent;document.body.prepend(textarea);textarea.style.position="absolute";textarea.style.opacity=0;textarea.select();document.execCommand("copy");textarea.remove();handler.textContent="COPIED!";setTimeout(()=>(handler.textContent="COPY"),2000);});const langCard=document.createElement("span");const lang=block.querySelector(".chroma > code").classList.toString().split("language-")[1];langCard.textContent=lang;langCard.style.top="0";langCard.style.left="1rem";langCard.style.color="#ffffff";langCard.style.fontSize="0.7em";langCard.style.position="absolute";langCard.style.background="#3f51b5";langCard.style.padding="0.25rem 0.5rem";langCard.style.textTransform="uppercase";langCard.style.borderRadius="0 0 4px 4px";block.prepend(langCard);block.prepend(handler);});}})();</script></body></html>