<!doctype html><html lang=en><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://g-savitha.github.io/css/base.css media=all><link rel=stylesheet href=https://g-savitha.github.io/css/syntax.css media=all><link href="https://fonts.googleapis.com/css2?family=Oxygen:wght@300;400;700&display=swap" rel=stylesheet><script async src=https://kit.fontawesome.com/66c0687ece.js crossorigin=anonymous></script><meta name=description content="Intro to recursion What is recursion?
Recursion : A function calling itself directly or indirectly.
Directly:
1void fun1(){ 2 //somecode ... 3 fun1(); 4 //some other code... 5} Indirectly: Not a very common approach (Mostly direct recursive approach is used)
fun1() -> fun2() -> fun1()
1void fun1(){ 2 //somecode ... 3 fun2(); 4 //some other code... 5} 6void fun2(){ 7 //somecode ... 8 fun1(); 9 //some other code... 10} 11 12  If you dont add a base case, recursion never stops and we might end up with stackoverflow(in case of java) or segmentation fault error(in case of cpp)."><meta name=title content="Recursion | Savitha's Notes"><meta name=keywords content="tech,programming,javascript,react,rust,nodejs,node,mongodb,postgresql"><meta name=robots content="index, follow"><meta charset=utf-8><meta name=language content="English"><meta name=revisit-after content="2 days"><meta name=author content="Abdus <mail@abdus.xyz>"><meta property="og:type" content="website"><meta property="og:url" content="https://g-savitha.github.io/notes/recursion/"><meta property="og:title" content="Recursion | Savitha's Notes"><meta property="og:description" content="Intro to recursion What is recursion?
Recursion : A function calling itself directly or indirectly.
Directly:
1void fun1(){ 2 //somecode ... 3 fun1(); 4 //some other code... 5} Indirectly: Not a very common approach (Mostly direct recursive approach is used)
fun1() -> fun2() -> fun1()
1void fun1(){ 2 //somecode ... 3 fun2(); 4 //some other code... 5} 6void fun2(){ 7 //somecode ... 8 fun1(); 9 //some other code... 10} 11 12  If you dont add a base case, recursion never stops and we might end up with stackoverflow(in case of java) or segmentation fault error(in case of cpp)."><meta property="og:image" content="https://g-savitha.github.io/images/default-meta-img.png"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://g-savitha.github.io/notes/recursion/"><meta property="twitter:title" content="Recursion | Savitha's Notes"><meta property="twitter:description" content="Intro to recursion What is recursion?
Recursion : A function calling itself directly or indirectly.
Directly:
1void fun1(){ 2 //somecode ... 3 fun1(); 4 //some other code... 5} Indirectly: Not a very common approach (Mostly direct recursive approach is used)
fun1() -> fun2() -> fun1()
1void fun1(){ 2 //somecode ... 3 fun2(); 4 //some other code... 5} 6void fun2(){ 7 //somecode ... 8 fun1(); 9 //some other code... 10} 11 12  If you dont add a base case, recursion never stops and we might end up with stackoverflow(in case of java) or segmentation fault error(in case of cpp)."><meta property="twitter:image" content="https://g-savitha.github.io/images/default-meta-img.png"><title>Recursion | Savitha's Notes</title><meta name=google-site-verification content="SaBE4itR48HOEifszgie57M1Y1O9Ayk_rV5cBwah9LY"><body><small class=top-nav><a href=/>~/Home</a>
<a href=/notes/>~/Notes</a>
<a href=/categories/>~/Categories</a></small>
<a href=https://g-savitha.github.io/ style=text-align:center;display:block;margin-top:3rem><div class=logo><span>#"</span><span>Savitha's Notes</span><span>"</span></div></a><div id=content><div style="text-align:center;margin:3rem 0"><h2>Recursion</h2><small>23 August, 2020&nbsp;&nbsp;&#183;&nbsp;&nbsp;</small>
<small><a style=text-decoration:none href=/categories/dsa>Dsa</a>
<a style=text-decoration:none href=/categories/recursion>Recursion</a></small></div><div class=section-content style=color:#252525><h2 id=intro-to-recursion>Intro to recursion</h2><p>What is recursion?</p><p><em>Recursion</em> : A function calling itself directly or indirectly.</p><p><em>Directly:</em></p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=ln>1</span><span class=kt>void</span> <span class=nf>fun1</span><span class=p>(){</span>
<span class=ln>2</span>    <span class=c1>//somecode ...
</span><span class=ln>3</span><span class=c1></span>    <span class=n>fun1</span><span class=p>();</span>
<span class=ln>4</span>    <span class=c1>//some other code...
</span><span class=ln>5</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p><em>Indirectly:</em> Not a very common approach (Mostly direct recursive approach is used)</p><p>fun1() -> fun2() -> fun1()</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=ln> 1</span><span class=kt>void</span> <span class=nf>fun1</span><span class=p>(){</span>
<span class=ln> 2</span>    <span class=c1>//somecode ...
</span><span class=ln> 3</span><span class=c1></span>    <span class=n>fun2</span><span class=p>();</span>
<span class=ln> 4</span>    <span class=c1>//some other code...
</span><span class=ln> 5</span><span class=c1></span><span class=p>}</span>
<span class=ln> 6</span><span class=kt>void</span> <span class=nf>fun2</span><span class=p>(){</span>
<span class=ln> 7</span>    <span class=c1>//somecode ...
</span><span class=ln> 8</span><span class=c1></span>    <span class=n>fun1</span><span class=p>();</span>
<span class=ln> 9</span>    <span class=c1>//some other code...
</span><span class=ln>10</span><span class=c1></span><span class=p>}</span>
<span class=ln>11</span>
<span class=ln>12</span>
</code></pre></div><ul><li>If you <em>dont add a base case</em>, <em>recursion never stops</em> and we might end up with <em>stackoverflow</em>(in case of java) or <em>segmentation fault</em> error(in case of cpp).</li><li>There should be <strong>one stopping condition atleast</strong>. Such stopping conditions are called <em><em>Base cases</em></em></li></ul><p><em>Example:</em></p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=ln> 1</span><span class=kt>void</span> <span class=nf>fun1</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
<span class=ln> 2</span><span class=p>{</span>
<span class=ln> 3</span>    <span class=c1>//Base Case
</span><span class=ln> 4</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
<span class=ln> 5</span>        <span class=k>return</span><span class=p>;</span>
<span class=ln> 6</span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Function 1&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
<span class=ln> 7</span>    <span class=n>fun1</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
<span class=ln> 8</span><span class=p>}</span>
<span class=ln> 9</span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
<span class=ln>10</span><span class=p>{</span>
<span class=ln>11</span>    <span class=cm>/* code */</span>
<span class=ln>12</span>    <span class=n>fun1</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
<span class=ln>13</span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=ln>14</span><span class=p>}</span>
<span class=ln>15</span>
</code></pre></div><h3 id=typical-structure-of-a-recursion>Typical structure of a recursion</h3><p>(Assuming: You are not using global vars or some other tricks to stop recursion ).</p><div class=highlight><pre class=chroma><code class=language-plaintext data-lang=plaintext><span class=ln>1</span>returntype function(parameters){
<span class=ln>2</span>    Base cases
<span class=ln>3</span>    //some other code.....
<span class=ln>4</span>    Recursive call (i.e., call to function()) with atleast one change in parameters
<span class=ln>5</span>    //some other code...
<span class=ln>6</span>}
</code></pre></div><h2 id=applications-of-recursion>Applications of recursion</h2><p>Any problem which can be solved iteratively can also be solved using recursively and vice-versa. They both have same expressive power.</p><p>Now the question is if we can write equivalent iterative code for every recursive code or vice versa, <strong>where do we use recursion?</strong></p><ul><li><p>Many algorithm techniques are based on recursion.</p><ul><li><strong>Dynamic programming</strong><ul><li>In DP, generally <em>first solution is to write a recursive solution</em>. If we see overlapping subproblems (apply memoization or tabulation), we use DP to optimise it.</li><li><em>Example:</em> Finding diff between two files (solved using LCS approach)</li></ul></li><li><strong>Backtracking</strong><ul><li>These problems are <em>inherently recursive</em> in nature.<ul><li><em>Example</em> : Rat in a maze, n-queens problem. (Its easy to write recursive solns than iterative for problems like this)</li></ul></li></ul></li><li><strong>Divide and conquer</strong><ul><li><em>Examples:</em> Binary search, quicksort and mergesort</li></ul></li></ul></li><li><p>Many problems which are <em>inherently recursive</em> (Easy to write recursive than iterative)</p><ul><li><strong>Towers of Hanoi</strong></li><li><strong>DFS based travels</strong><ul><li>Of <em>Graphs</em></li><li>Inorder, preorder postorder traversals of <em>tree</em></li><li>Searching for a file in your pc - solid example of DFS</li></ul></li></ul></li><li><p><em>Cons of recursion</em></p><ul><li>(Auxillary) space complexity increases</li><li>Function call overhead.</li></ul></li><li><p><em>Pros:</em></p><ul><li>Easy implementation</li></ul></li></ul><h2 id=examples>Examples</h2><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=ln> 1</span><span class=kt>void</span> <span class=nf>fun1</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
<span class=ln> 2</span><span class=p>{</span>
<span class=ln> 3</span>
<span class=ln> 4</span>    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
<span class=ln> 5</span>        <span class=k>return</span><span class=p>;</span> <span class=c1>//Base Case
</span><span class=ln> 6</span><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>n</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
<span class=ln> 7</span>    <span class=n>fun1</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
<span class=ln> 8</span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>n</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
<span class=ln> 9</span><span class=p>}</span>
<span class=ln>10</span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
<span class=ln>11</span><span class=p>{</span>
<span class=ln>12</span>    <span class=cm>/* code */</span>
<span class=ln>13</span>    <span class=n>fun1</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
<span class=ln>14</span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=ln>15</span><span class=p>}</span>
<span class=ln>16</span><span class=c1>//Output : 321123
</span></code></pre></div><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=ln> 1</span><span class=kt>void</span> <span class=nf>fun1</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
<span class=ln> 2</span><span class=p>{</span>
<span class=ln> 3</span>
<span class=ln> 4</span>    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
<span class=ln> 5</span>        <span class=k>return</span><span class=p>;</span> <span class=c1>//Base Case
</span><span class=ln> 6</span><span class=c1></span>    <span class=n>fun1</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
<span class=ln> 7</span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>n</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
<span class=ln> 8</span>    <span class=n>fun1</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
<span class=ln> 9</span><span class=p>}</span>
<span class=ln>10</span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=k>const</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
<span class=ln>11</span><span class=p>{</span>
<span class=ln>12</span>    <span class=cm>/* code */</span>
<span class=ln>13</span>    <span class=n>fun1</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
<span class=ln>14</span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=ln>15</span><span class=p>}</span>
<span class=ln>16</span><span class=c1>//Output : 1213121
</span></code></pre></div><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=ln> 1</span><span class=kt>int</span> <span class=nf>fn</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
<span class=ln> 2</span><span class=p>{</span>
<span class=ln> 3</span>    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
<span class=ln> 4</span>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=ln> 5</span>    <span class=k>else</span>
<span class=ln> 6</span>        <span class=k>return</span> <span class=mi>1</span> <span class=o>+</span> <span class=n>fn</span><span class=p>(</span><span class=n>n</span> <span class=o>/</span> <span class=mi>2</span><span class=p>);</span>
<span class=ln> 7</span><span class=p>}</span>
<span class=ln> 8</span><span class=c1>//TC: O(floor(logn base2))
</span><span class=ln> 9</span><span class=c1>//SC: O(n/2)
</span><span class=ln>10</span><span class=c1>//fn(16) -&gt; O/p: 4 =&gt; (1+f(8)) -&gt;(1+1+f(4)) -&gt;(1+1+1+f(2)) -&gt; (1+1+1+1+f(1))
</span><span class=ln>11</span><span class=c1>//fn(20) -&gt; o/p: 4 =&gt;(1+f(10)) -&gt; (1+1+f(5)) -&gt; (1+1+1+f(2)) -&gt; (1+1+1+1+f(1))
</span><span class=ln>12</span><span class=c1>//fn(19) -&gt; o/p:4 =&gt; (1+f(9)) -&gt; (1+1+f(4)) -&gt; -&gt;(1+1+1+f(2)) -&gt; (1+1+1+1+f(1))
</span><span class=ln>13</span><span class=c1></span>
<span class=ln>14</span><span class=c1>//output remains same until we get to next power of 2.
</span></code></pre></div><blockquote><p>Binary representation of a number(n > 0) using recursion</p></blockquote><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=ln>1</span><span class=kt>int</span> <span class=nf>fn</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
<span class=ln>2</span><span class=p>{</span>
<span class=ln>3</span>    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
<span class=ln>4</span>        <span class=k>return</span><span class=p>;</span>
<span class=ln>5</span>    <span class=n>fn</span><span class=p>(</span><span class=n>n</span> <span class=o>/</span> <span class=mi>2</span><span class=p>);</span>
<span class=ln>6</span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>n</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
<span class=ln>7</span><span class=p>}</span>
<span class=ln>8</span><span class=c1>//TC:
</span></code></pre></div><blockquote><p>print 1 to N using recursion</p></blockquote><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=ln>1</span><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>fn</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
<span class=ln>2</span>    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span>
<span class=ln>3</span>        <span class=k>return</span><span class=o>;</span>
<span class=ln>4</span>    <span class=n>fn</span><span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>1</span><span class=o>);</span>
<span class=ln>5</span>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>n</span><span class=o>);</span>
<span class=ln>6</span><span class=o>}</span><span class=c1>//TC; O(n) AS: O(n+1)
</span></code></pre></div><blockquote><p>print N to 1 using recursion</p></blockquote><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=ln>1</span><span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>fn</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
<span class=ln>2</span>    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span>
<span class=ln>3</span>        <span class=k>return</span><span class=o>;</span>
<span class=ln>4</span>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>n</span><span class=o>);</span>
<span class=ln>5</span>        <span class=n>n</span><span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>1</span><span class=o>);</span>
<span class=ln>6</span><span class=o>}</span><span class=c1>// TC: theta(n)
</span><span class=ln>7</span><span class=c1>//SC: (Auxillary space) : O(n)
</span></code></pre></div><ul><li><strong>Note:</strong> We can reduce the auxillary space using <em><em>tail recursion</em></em>.<ul><li>The above fn takes less time on modern compilers because of tail recursion</li></ul></li></ul><h2 id=tail-recursion>Tail Recursion</h2><p>To understand tail recursion, lets take a closer look at these 2 functions.</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=ln>1</span><span class=c1>//prints from n to 1
</span><span class=ln>2</span><span class=c1></span><span class=kt>void</span> <span class=nf>fn1</span><span class=o>()</span> <span class=o>{</span>
<span class=ln>3</span>    <span class=k>if</span><span class=o>(</span><span class=n>n</span><span class=o>==</span><span class=n>0</span><span class=o>)</span> <span class=k>return</span><span class=o>;</span>
<span class=ln>4</span>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>n</span><span class=o>);</span>
<span class=ln>5</span>    <span class=n>fn1</span><span class=o>(</span><span class=n>n</span><span class=o>-</span><span class=n>1</span><span class=o>);</span>
<span class=ln>6</span><span class=o>}</span>
<span class=ln>7</span><span class=c1>//this function takes lesser time
</span></code></pre></div><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=ln>1</span><span class=c1>//prints from 1 to n
</span><span class=ln>2</span><span class=c1></span><span class=kt>void</span> <span class=nf>fn2</span><span class=o>(){</span>
<span class=ln>3</span>    <span class=k>if</span><span class=o>(</span><span class=n>n</span><span class=o>==</span><span class=n>0</span><span class=o>)</span> <span class=k>return</span><span class=o>;</span>
<span class=ln>4</span>    <span class=n>fn2</span><span class=o>(</span><span class=n>n</span><span class=o>-</span><span class=n>1</span><span class=o>);</span>
<span class=ln>5</span>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>n</span><span class=o>);</span>
<span class=ln>6</span><span class=o>}</span>
</code></pre></div><p>Can you guess the reason why would 1st function take lesser time to compile on modern compilers?</p><p>If you look at the call stack of <code>fn1()</code></p><pre><code class=language-tree data-lang=tree>+__fn1(3)
    |__ 3
    |__fn1(2)
        |__ 2
        |__ fn1(1)
            |__ 1
            |__ fn1(0)
</code></pre><p>When <code>fn1(0)</code> finishes, control returns back to <code>fn1(1)</code>, <code>fn1(1)</code> doesnt have anything to do it finishes immediately. This is where tail recursion comes into picture.</p><p>A function is called <strong>Tail recursive</strong> when the parent function has nothing to do when the child finishes the call.</p><p>This is not the case with <code>fn2(3)</code>. When <code>fn2(0)</code> returns to its parent <code>fn2(1)</code>, it still has got work to do (print the output).</p><p>In very simple words</p><blockquote><p>A function is called <strong>tail recursive</strong>, when the last thing that happens in the function is recursive call and nothing happens after that.</p></blockquote><h3 id=what-are-the-pros-of-this>What are the pros of this?</h3><p>The point is your caller doesn&rsquo;t have to save the state, generally what happens in recursive calls is, caller&rsquo;s state is saved then called function is called and once the called function is finished then the caller resumes its function from the same point. We dont need to resume the execution here at all, there&rsquo;s no point in resuming the execution and thats what the optimisation modern compilers do.</p><p>When modern compilers see tail recursive functions they replace the above code with</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=ln>1</span><span class=kt>void</span> <span class=nf>fn1</span><span class=o>()</span> <span class=o>{</span>
<span class=ln>2</span>    <span class=c1>//compiler adds this label
</span><span class=hl><span class=ln>3</span><span class=c1></span>    <span class=n>start</span><span class=o>:</span>
</span><span class=ln>4</span>        <span class=k>if</span><span class=o>(</span><span class=n>n</span><span class=o>==</span><span class=n>0</span><span class=o>)</span> <span class=k>return</span><span class=o>;</span>
<span class=ln>5</span>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>n</span><span class=o>);</span>
<span class=ln>6</span>        <span class=c1>// and replaces the line fn1(n-1) with below statements
</span><span class=hl><span class=ln>7</span><span class=c1></span>        <span class=n>n</span><span class=o>=</span> <span class=n>n</span><span class=o>-</span><span class=n>1</span> <span class=o>;</span>
</span><span class=hl><span class=ln>8</span>        <span class=k>goto</span> <span class=n>start</span><span class=o>;</span>
</span><span class=ln>9</span><span class=o>}</span>
</code></pre></div><p>These changes that modern compilers make are called <strong>Tail call elimination</strong></p><p>Now, the question arises is when given a non tail recursive code, can we convert it tail recursive?</p><p>Lets have a look at the below examples.</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=ln>1</span><span class=c1>//prints from 1 to n
</span><span class=ln>2</span><span class=c1></span><span class=kt>void</span> <span class=nf>fn2</span><span class=o>(){</span>
<span class=ln>3</span>    <span class=k>if</span><span class=o>(</span><span class=n>n</span><span class=o>==</span><span class=n>0</span><span class=o>)</span> <span class=k>return</span><span class=o>;</span>
<span class=ln>4</span>    <span class=n>fn2</span><span class=o>(</span><span class=n>n</span><span class=o>-</span><span class=n>1</span><span class=o>);</span>
<span class=ln>5</span>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>n</span><span class=o>);</span>
<span class=ln>6</span><span class=o>}</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=ln>1</span><span class=c1>//Tail recursive version of the code
</span><span class=ln>2</span><span class=c1>//initially pass k = 1
</span><span class=ln>3</span><span class=c1></span><span class=kt>void</span> <span class=nf>fn2</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>,</span> <span class=kt>int</span> <span class=n>k</span><span class=o>){</span>
<span class=ln>4</span>    <span class=k>if</span><span class=o>(</span><span class=n>n</span><span class=o>==</span><span class=n>0</span><span class=o>)</span> <span class=k>return</span><span class=o>;</span>
<span class=ln>5</span>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>k</span><span class=o>);</span>
<span class=ln>6</span>    <span class=n>fn2</span><span class=o>(</span><span class=n>n</span><span class=o>-</span><span class=n>1</span><span class=o>,</span><span class=n>k</span><span class=o>+</span><span class=n>1</span><span class=o>);</span>
<span class=ln>7</span><span class=o>}</span>
</code></pre></div><p>Can we convert every non tail recursive to tail recursive by adding few parameters?</p><p><strong>No.</strong> Consider <a href=https://www.geeksforgeeks.org/merge-sort/>merge sort</a> and <a href=https://www.geeksforgeeks.org/quick-sort/>quick sort</a>, if you take a closer look at these two algorithms, quick sort is tail recursive and merge sort is not. This is one of the reasons, quick sort is fast.</p><p>In case of <a href=https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/>tree traversals (Inorder,preorder and postorder)</a>, you can notice that preorder traversal and inorder traversal are tail recursive, but post order traversal is not, thats why when you are given a problem and if you can choose any of the traversals, you should prefer either inorder or preorder over the postorder.</p><h3 id=is-this-tail-recursive>Is this tail recursive?</h3><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=ln>1</span><span class=kt>int</span> <span class=nf>factorial</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>){</span>
<span class=ln>2</span>    <span class=k>if</span><span class=o>(</span><span class=n>n</span><span class=o>==</span><span class=n>0</span> <span class=o>||</span> <span class=n>n</span><span class=o>==</span> <span class=n>1</span><span class=o>)</span> <span class=k>return</span> <span class=n>1</span><span class=o>;</span>
<span class=ln>3</span>    <span class=k>return</span> <span class=n>n</span> <span class=o>*</span> <span class=n>factorial</span><span class=o>(</span><span class=n>n</span><span class=o>-</span><span class=n>1</span><span class=o>);</span>
<span class=ln>4</span><span class=o>}</span>
</code></pre></div><p><strong>No.</strong> The reason is recursion is not the last thing that happens in this function. When you call <code>factorial(n-1)</code> you need to know the result of that function and multiply it with <code>n</code> and then it need to return. Parent call doesn&rsquo;t finish immediately after the child call, its going to use the result of child call and then multiply the result with <code>n</code> after that its going to return.</p><h4 id=equivalent-tail-recursive-code>Equivalent tail recursive code</h4><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=ln>1</span><span class=c1>//initially pass k = 1
</span><span class=ln>2</span><span class=c1></span><span class=kt>int</span> <span class=nf>factorial</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>,</span> <span class=kt>int</span> <span class=n>k</span><span class=o>){</span>
<span class=ln>3</span>    <span class=k>if</span><span class=o>(</span><span class=n>n</span><span class=o>==</span><span class=n>0</span> <span class=o>||</span> <span class=n>n</span><span class=o>==</span> <span class=n>1</span><span class=o>)</span> <span class=k>return</span> <span class=n>k</span><span class=o>;</span>
<span class=ln>4</span>    <span class=k>return</span> <span class=n>factorial</span><span class=o>(</span><span class=n>n</span><span class=o>-</span><span class=n>1</span><span class=o>,</span><span class=n>k</span><span class=o>*</span><span class=n>n</span><span class=o>);</span>
<span class=ln>5</span><span class=o>}</span>
</code></pre></div><hr><p>Few problems on recursion worth looking at:</p><ul><li><a href=https://www.geeksforgeeks.org/cutting-a-rod-dp-13/>Rod cutting</a></li><li><a href=https://www.geeksforgeeks.org/backtracking-to-find-all-subsets/>Generate subsets of an array</a></li><li><a href=https://www.geeksforgeeks.org/josephus-problem-set-1-a-on-solution/>Josephus Problem</a></li><li><a href=https://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/>Print all permutations of a string</a></li><li><a href=https://www.geeksforgeeks.org/subset-sum-problem-dp-25/>Subset sum problem</a></li></ul></div><div style=margin-top:2rem><i class="fas fa-tags" style=font-size:.7em;color:gray></i><a style="border:0;font-size:.8em;padding:0 4px;text-decoration:none" href=/tags/ds-algo>&nbsp;ds-algo</a>
<a style="border:0;font-size:.8em;padding:0 4px;text-decoration:none" href=/tags/programming>&nbsp;programming</a>
<a style="border:0;font-size:.8em;padding:0 4px;text-decoration:none" href=/tags/competitive-programming>&nbsp;competitive-programming</a></div><div style=margin-top:5rem><a href=https://g-savitha.github.io/notes/ch-01-intro-to-react/ class="prev-next newer">&Larr;Intro to React</a></div><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/g-savitha.github.io\/"},"articleSection":"notes","name":"Recursion","headline":"Recursion","description":"Intro to recursion What is recursion?\nRecursion : A function calling itself directly or indirectly.\nDirectly:\n1void fun1(){ 2 \/\/somecode ... 3 fun1(); 4 \/\/some other code... 5} Indirectly: Not a very common approach (Mostly direct recursive approach is used)\nfun1() -\u0026gt; fun2() -\u0026gt; fun1()\n1void fun1(){ 2 \/\/somecode ... 3 fun2(); 4 \/\/some other code... 5} 6void fun2(){ 7 \/\/somecode ... 8 fun1(); 9 \/\/some other code... 10} 11 12  If you dont add a base case, recursion never stops and we might end up with stackoverflow(in case of java) or segmentation fault error(in case of cpp).","inLanguage":"en-US","author":"Savitha","creator":"Savitha","publisher":"Savitha","accountablePerson":"Savitha","copyrightHolder":"Savitha","copyrightYear":"23238","datePublished":"2020-08-23 17:17:32 \u002b0530 \u002b0530","dateModified":"2020-08-23 17:17:32 \u002b0530 \u002b0530","url":"https:\/\/g-savitha.github.io\/notes\/recursion\/","wordCount":"1301","keywords":["ds-algo","programming","competitive-programming","Blog"]}</script><script type=module>
  import { annotate } from "https://unpkg.com/rough-notation?module";

  function checkParent(elem) {
    const parent = elem.parentElement;
    const strong = document.createElement("strong");
    const em = document.createElement("em");
    const del = document.createElement("del");
    console.log(elem.hasChildNodes(), elem);

    if (
      parent.constructor === strong.constructor ||
      parent.constructor === em.constructor ||
      parent.constructor === del.constructor
    )
      return false;
    if (elem.childElementCount > 0) return false;
    return true;
  }

  function annotateElement(selector, type, color) {
    document.querySelectorAll(selector).forEach((elem) => {
      const shouldAllowAnnotation = checkParent(elem);
      if (shouldAllowAnnotation)
        annotate(elem, { type, color, multiline: true, animate: false }).show();
    });
  }

  function annotateNestedElement(selector, type, color) {
    document.querySelectorAll(selector).forEach((elem) => {
      annotate(elem, {
        type,
        color,
        multiline: true,
        animate: false,
        brackets: ["left", "right", "top", "bottom"],
      }).show();
    });
  }

  try {
    annotateElement("em", "underline", "#2196f3");
    annotateElement("strong", "highlight", "yellow");
    annotateElement("del", "strike-through", "#ff0000");
    annotateNestedElement("em > del", "crossed-off", "#ff0000");
    annotateNestedElement("em > strong", "box", "lawngreen");
    annotateNestedElement("em > em", "circle", "#ff000080");
    annotateNestedElement("blockquote", "bracket", "#da3bf1");
  } catch (exception) {
    console.log(exception.message);
  }
</script><style>.section-content em,.section-content strong,.section-content del{font-style:normal;font-weight:400;text-decoration:none}blockquote{background-color:#fff;padding:.3rem;margin:2rem 0}</style></div><footer style="padding:6rem 1rem 2rem;text-align:center;color:gray"><small>built with <a href=https://gohugo.io>hugo</a> and
<span style=color:red>❤️</span> <span>&#169; 2020</span>
<a href=https://github.com/g-savitha>Savitha Gollamudi</a></small></footer><script>(()=>{if(document.queryCommandSupported("copy")){const codeBlocks=[...document.querySelectorAll(".highlight")];codeBlocks.forEach((block)=>{block.querySelector("pre.chroma").style.paddingTop="3rem";block.style.position="relative";const handler=document.createElement("button");handler.textContent="COPY";handler.style.position="absolute";handler.style.top="10px";handler.style.right="10px";handler.style.padding="0.25rem 0.5rem";handler.style.background="#272822";handler.style.borderRadius="4px";handler.style.border="1px solid #C9D5DE";handler.style.color="#ffffff";handler.addEventListener("click",()=>{const textarea=document.createElement("textarea");textarea.value=block.querySelector(".chroma > code").textContent;document.body.prepend(textarea);textarea.style.position="absolute";textarea.style.opacity=0;textarea.select();document.execCommand("copy");textarea.remove();handler.textContent="COPIED!";setTimeout(()=>(handler.textContent="COPY"),2000);});const langCard=document.createElement("span");const lang=block.querySelector(".chroma > code").classList.toString().split("language-")[1];langCard.textContent=lang;langCard.style.top="0";langCard.style.left="1rem";langCard.style.color="#ffffff";langCard.style.fontSize="0.7em";langCard.style.position="absolute";langCard.style.background="#3f51b5";langCard.style.padding="0.25rem 0.5rem";langCard.style.textTransform="uppercase";langCard.style.borderRadius="0 0 4px 4px";block.prepend(langCard);block.prepend(handler);});}})();</script></body></html>